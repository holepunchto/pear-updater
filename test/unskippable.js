const test = require('brittle')
const tmp = require('test-tmp')
const { createDrives, eventFlush } = require('./helpers')
const Updater = require('../index')
const { promises: fsp } = require('fs')
const path = require('path')
const nodeBundle = require('node-bare-bundle')

test('should follow unskippable updates', async function (t) {
  t.plan(12)

  const directory = await tmp(t)
  const [drive, clone] = await createDrives(t)
  const u = new Updater(clone, { directory, host: 'universal-universal' })

  const unskippables = []

  await drive.put('/checkout.js', '')
  await drive.put('/own-main.js', 'module.exports = require("./checkout.js")')
  await drive.put('/package.json', JSON.stringify({ main: 'own-main.js' }))
  unskippables.push({ key: drive.core.id, length: drive.core.length })
  await drive.put('/checkout.js', 'console.log("hello")')
  unskippables.push({ key: drive.core.id, length: drive.core.length })
  await drive.put('/checkout.js', 'console.log("hello")\nconsole.log("world")')
  await drive.put('/checkout.js', 'console.log("hello")\nconsole.log("world")\nconsole.log("universe")')
  unskippables.push({ key: drive.core.id, length: drive.core.length })
  await drive.put('/package.json', JSON.stringify({ main: 'own-main.js', pear: { updates: { unskippable: unskippables } } }))
  t.comment(`Final drive length is ${drive.core.length}`)

  t.comment(`Updating to ${unskippables[0].length}`)
  await eventFlush()
  await u.update()
  await u.applyUpdate()
  const entrypoint1 = await fsp.readFile(path.join(u.swap, 'own-main.bundle'), 'utf-8')
  const checkout1 = nodeBundle(entrypoint1)
  t.is(checkout1.length, unskippables[0].length, 'Checkout matches unskippable')
  t.is(checkout1.fork, drive.core.fork, 'Fork matches')
  t.is(checkout1.key, drive.core.id, 'Key matches')

  t.comment(`Updating to ${unskippables[1].length}`)
  await eventFlush()
  await u.update()
  await u.applyUpdate()
  const entrypoint2 = await fsp.readFile(path.join(u.swap, 'own-main.bundle'), 'utf-8')
  const checkout2 = nodeBundle(entrypoint2)
  t.is(checkout2.length, unskippables[1].length, 'Checkout matches unskippable')
  t.is(checkout2.fork, drive.core.fork, 'Fork matches')
  t.is(checkout2.key, drive.core.id, 'Key matches')

  t.comment(`Updating to ${unskippables[2].length}`)
  await eventFlush()
  await u.update()
  await u.applyUpdate()
  const entrypoint3 = await fsp.readFile(path.join(u.swap, 'own-main.bundle'), 'utf-8')
  const checkout3 = nodeBundle(entrypoint3)
  t.is(checkout3.length, unskippables[2].length, 'Checkout matches unskippable')
  t.is(checkout3.fork, drive.core.fork, 'Fork matches')
  t.is(checkout3.key, drive.core.id, 'Key matches')

  t.comment('Updating to latest')
  await eventFlush()
  await u.update()
  await u.applyUpdate()
  const entrypoint = await fsp.readFile(path.join(u.swap, 'own-main.bundle'), 'utf-8')
  const checkout = nodeBundle(entrypoint)
  t.is(checkout.length, drive.core.length, 'Final checkout matches drive length')
  t.is(checkout.fork, drive.core.fork, 'Fork matches')
  t.is(checkout.key, drive.core.id, 'Key matches')
})
